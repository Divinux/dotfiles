#!/bin/bash

# ===========================
# Linux Terminal Gamifier v1
# ===========================
# This script gamifies your terminal by tracking experience points and levels
# based on the number of commands you execute. Newly found commands give more exp,
# repeated commands less, wrong commands still give a little. At least you tried.
#
# Setup:
# 1. Save this file in your home directory (or anywhere else)
#        curl --output ~/gamifier "https://raw.githubusercontent.com/Divinux/dotfiles/refs/heads/main/scripts/gamifier"
# 2. Source the file in your bashrc. This can be done manually or (assuming you saved it in your home dir) by running
#        echo 'source ~/gamifier' >> ~/.bashrc
# 3. Ensure your history is reloaded after each command, then call update_exp
#    If you have not yet modified your PROMPT_COMMAND, you can simply run
#        echo 'export PROMPT_COMMAND="history -a; history -n; update_exp; $PROMPT_COMMAND"' >> ~/.bashrc
# 4. Restart your terminal or run 
#        source ~/.bashrc
#
# Additional info:
# 1. This script creates two additional files; .exp and .usedcommands
#    .exp is used to track the current experience amount and level
#    .usedcommands contains all commands the user used so far
#    To continue tracking your progress on a new install, just copy these files over to your new home directory
# 2. You may want to increase your HISTSIZE and HISTFILESIZE.
#    Setting them to nothing, i.e. "HISTSIZE=" and "HISTFILESIZE=" makes them unlimited
# 3. You can use checkrank at any time to check your current progress.
# 4. Use ghelp to display a short info message.
#
# Uninstall:
# 1. Remove 'source ~/gamifier' and update_exp; from your bashrc
# 2. Delete the gamifier, .exp and .usedcommands files
# 3. Restart your terminal

exp_file="$HOME/.exp"
used_commands_file="$HOME/.usedcommands"

# Notification settings
notify_on_new=true
notify_on_reused=false
notify_on_false_new=true
notify_on_false_reused=false

# Custom messages
msg_new_command="New command discovered!"
msg_repeat_command="Experience gained!"
msg_false_new_command="Incorrect command! At least you tried!"
msg_false_repeat_command="Trying incorrect command again..."

# EXP settings
exp_new_command=5
exp_reused_command=2
exp_false_new_command=1
exp_false_reused_command=0

# EXP curve
exp_increase_percent=6
exp_base=10

# Initialize .exp file if it doesn't exist
if [ ! -f "$exp_file" ]; then
    echo "EXP=0" > "$exp_file"
    echo "LVL=1" >> "$exp_file"
fi

# Initialize .usedcommands file if it doesn't exist
if [ ! -f "$used_commands_file" ]; then
    touch "$used_commands_file"
fi

# Function to get the current EXP
get_exp() {
    grep "EXP=" "$exp_file" | cut -d'=' -f2
}

# Function to set EXP
set_exp() {
    sed -i "s/^EXP=.*/EXP=$1/" "$exp_file"
}

# Function to get the current LVL
get_lvl() {
    grep "LVL=" "$exp_file" | cut -d'=' -f2
}

# Function to determine EXP required for next level
exp_needed_for_level() {
    local lvl=$(get_lvl)

    if [ "$lvl" -eq 1 ]; then
        echo "$exp_base"
    else
        echo $(echo "$exp_base * (($exp_increase_percent + 100) ^ ($lvl - 1)) / (100 ^ ($lvl - 1))" | bc)
    fi
}

# Function to level up if needed
level_up() {
    local exp=$(get_exp)
    local lvl=$(get_lvl)
    local needed=$(exp_needed_for_level)

    while [ "$exp" -ge "$needed" ]; do
        new_lvl=$((lvl + 1))
        level_up_message "$new_lvl"
        sed -i "s/^LVL=.*/LVL=$new_lvl/" "$exp_file"
        exp=$((exp - needed))
        needed=$(exp_needed_for_level)
        lvl=$new_lvl
    done
    set_exp "$exp"
}

# Get initial history count
histfile="$HOME/.bash_history"
prev_hist_count=$(wc -l < "$histfile")

# Helper function to handle command use
handle_command() {
    local command=$1
    local exp_increment=$2
    local message=$3
    local notify=$4

    # Check if the command has been used before
    if ! grep -qx "$command" "$used_commands_file"; then
        # If it's new, add it to the .usedcommands file
        echo "$command" >> "$used_commands_file"
    fi

    # Update EXP
    exp=$(get_exp)
    new_exp=$((exp + exp_increment))
    set_exp "$new_exp"

    # If notification is enabled, print message
    if [ "$notify" = true ]; then
        echo "$message"
		# If any EXP was gained, echo the new EXP to the console
        if [ "$exp_increment" -gt 0 ]; then
            echo "Current EXP: $new_exp"
        fi
    fi
}

# Hook into the shell prompt
update_exp() {
    local new_count=$(wc -l < "$histfile")

    if [ "$new_count" -gt "$prev_hist_count" ]; then
        prev_hist_count="$new_count"

        # Get the last command entered
        local last_command=$(tail -n 1 "$histfile")
        local first_word=$(echo "$last_command" | awk '{print $1}')

        # If command starts with sudo, extract the actual command being run
        if [[ "$first_word" == "sudo" ]]; then
            first_word=$(echo "$last_command" | awk '{print $2}')
        fi

        # Check if the command is valid (not "command not found")
        if command -v "$first_word" &> /dev/null; then
            # If valid, handle it with exp_new_command for first-time use, exp_reused_command for subsequent use
            if ! grep -qx "$last_command" "$used_commands_file"; then
                handle_command "$last_command" "$exp_new_command" "$msg_new_command" "$notify_on_new"
            else
                handle_command "$last_command" "$exp_reused_command" "$msg_repeat_command" "$notify_on_reused"
            fi
        else
            # If invalid, handle it with exp_false_new_command for first-time use, exp_false_reused_command for subsequent invalid use
            if ! grep -qx "$last_command" "$used_commands_file"; then
                handle_command "$last_command" "$exp_false_new_command" "$msg_false_new_command" "$notify_on_false_new"
            else
                handle_command "$last_command" "$exp_false_reused_command" "$msg_false_repeat_command" "$notify_on_false_reused"
            fi
        fi

        # Check for level up
        level_up
    fi
}

# Checks the current level
checkrank() {
    local level=$(get_lvl)
    local exp=$(get_exp)
    local needed=$(exp_needed_for_level)
    local rank=$(get_rank "$level")
    local rank_padding_left=$(( (26 - ${#rank}) / 2 ))
    local rank_padding_right=$(( 26 - ${#rank} - rank_padding_left ))
    local rank_line="||$(printf '%*s' $rank_padding_left) $rank $(printf '%*s' $rank_padding_right)||"
    local exp_padding_left=$(( (26 - ${#exp} - ${#needed} - 6) / 2 ))
    local exp_padding_right=$(( 26 - ${#exp} - ${#needed} - 6 - exp_padding_left ))
    local exp_line="||$(printf '%*s' "$exp_padding_left") EXP: $exp/$needed $(printf '%*s' "$exp_padding_right")||"
    local quote=$(get_quote "$level")

    printf "\n================================\n"
    printf "||       CURRENT LEVEL        ||\n"
    printf "||         Level: %-5s       ||\n" "$level"
    printf "%s\n" "$exp_line"
    printf "%s\n" "$rank_line"
    printf "================================\n"
    printf "%s\n" "$quote"
    printf "================================\n\n"
}

# Level-up message
level_up_message() {
    local level=$1
    local rank=$(get_rank "$level")
    local rank_padding_left=$(( (26 - ${#rank}) / 2 ))
    local rank_padding_right=$(( 26 - ${#rank} - rank_padding_left ))
    local rank_line="||$(printf '%*s' $rank_padding_left) $rank $(printf '%*s' $rank_padding_right)||"
    local quote=$(get_quote "$level")
	
    printf "\n================================\n"
    printf "||          LEVEL UP!         ||\n"
    printf "||    You reached level %-5s ||\n" "$level"
    printf "%s\n" "$rank_line"
    printf "||                            ||\n"
    printf "||   ░░░░░░░░░▄▄▄▄▄░░░░░░░░   ||\n"
    printf "||   ░░░░░▄██████████▄░░░░░   ||\n"
    printf "||   ░░░▄██████████████▄░░░   ||\n"
    printf "================================\n"
    printf "%s\n" "$quote"
    printf "================================\n\n"
}

# Level-up ranks
get_rank() {
    local lvl=$1
    case $lvl in
        [1-4]) echo "Terminal Newbie" ;;
        [5-9]) echo "Script Kiddie" ;;
        1[0-4]) echo "Command Line Enthusiast" ;;
        1[5-9]) echo "Shell Apprentice" ;;
        2[0-4]) echo "Daemon Handler" ;;
        2[5-9]) echo "System Sorcerer" ;;
        3[0-9]) echo "Unix Warrior" ;;
        4[0-9]) echo "Pipe Artisan" ;;
        5[0-9]) echo "Network Nomad" ;;
        6[0-9]) echo "Bash Wizard" ;;
        7[0-9]) echo "Shell Savant" ;;
        8[0-9]) echo "Linux Warlock" ;;
        9[0-9]) echo "Archmage of the CLI" ;;
        *) echo "Root God" ;;
    esac
}

# rank quotes
get_quote() {
    local lvl=$1
    case $lvl in
        [1-4]) printf -- "  -\"Wait, how do I exit Vim?\"" ;;
        [5-9]) printf -- "  -\"I copied this from Stack \n    Overflow… hope it works.\"" ;;
        1[0-4]) printf -- "  -\"I run htop just to watch \n    the colors.\"" ;;
        1[5-9]) printf -- " -\"My .bashrc is literal art.\"" ;;
        2[0-4]) printf -- "  -\"I made a service… and it \n    stays running!\"" ;;
        2[5-9]) printf -- "  -\"My one-liner fixed your \n    DNS, and brewed coffee.\"" ;;
        3[0-9]) printf -- "  -\"I herd servers like cats.\"" ;;
        4[0-9]) printf -- "    -\"My scripts have error\n    handling… and comments.\"" ;;
        5[0-9]) printf -- "  -\"I SSH through three hops\n    just to say ‘hi’.\"" ;;
        6[0-9]) printf -- "  -\"I see regex in my sleep.\"" ;;
        7[0-9]) printf -- "   -\"I use vi to edit emacs\n       configs. Fight me.\"" ;;
        8[0-9]) printf -- "    -\"I filed a bug report…\n       and then fixed it.\"" ;;
        9[0-9]) printf -- "  -\"I speak in ANSI escape\n    codes and dream in JSON.\"" ;;
        *) printf -- "       -\"/dev/null is my\n         recycling bin.\"" ;;
    esac
}

# Displays help information
ghelp() {
    cat <<EOF

===========================
Linux Terminal Gamifier v1
===========================
This script gamifies your terminal by tracking experience points and levels
based on the number of commands you execute. Newly used commands give more exp,
repeated commands less, wrong commands still give a little. At least you tried.

You can use checkrank at any time to check your current progress.
Use ghelp to display this message.

EOF
}
